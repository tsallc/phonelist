import * as slugifyNs from "slugify";
import { createHash } from "crypto";
import {
  ContactEntity,
  CanonicalExport,
  ContactPoint,
  Role,
  ContactEntitySchema,
} from "./schema.js";
import { RawOfficeCsvRow } from "./types.js";
import { log } from "./logger.js";

const slugify = (slugifyNs as any).default ?? slugifyNs;

/** Generates a URL-friendly slug */
function generateSlug(name?: string): string {
  if (!name) return `unknown-${Date.now()}-${Math.random().toString(16).substring(2, 8)}`;
  return slugify(name, { lower: true, strict: true });
}

/** Generates a SHA256 hash for ID collision fallback */
function hashId(identifier: string, source: string): string {
  return createHash("sha256").update(identifier + source).digest("hex");
}

/**
 * Transforms an array of RawOfficeCsvRow objects into an array of full ContactEntity objects,
 * generating unique internal IDs.
 * Assumes rows represent external contacts.
 */
export function rowsToCanonical(rows: RawOfficeCsvRow[], source: string = 'Office365'): ContactEntity[] {
  const entities: ContactEntity[] = [];
  const usedIds = new Set<string>();

  for (const row of rows) {
    try {
      const objectId = row["object id"]?.trim(); 
      if (!objectId) {
        throw new Error(`Missing required 'object id'.`);
      }
      const displayName = row["display name"]?.trim() || undefined;
      const mobilePhone = row["mobile phone"]?.trim() || undefined;
      const upn = row["user principal name"]?.trim() || undefined;
      const title = row["title"]?.trim() || undefined;
      const department = row["department"]?.trim() || undefined;

      const contactPoints: ContactPoint[] = [];
      if (mobilePhone) {
        contactPoints.push({ type: "mobile", value: mobilePhone, source: source as ContactPoint['source'] }); // Added type assertion
      }

      const roles: Role[] = [];
      if (title) {
        roles.push({ office: "PLY", brand: "tsa", title, priority: 1 });
      }

      let id = generateSlug(displayName);
      if (usedIds.has(id)) {
        const fallbackIdentifier = upn || `${displayName}-${objectId?.substring(0,4) || 'no-id'}`;
        id = hashId(fallbackIdentifier, source);
      }
      usedIds.add(id);

      const finalEntity: ContactEntity = {
        id,
        kind: "external", // Explicitly set kind
        objectId,         // Required for external
        displayName,
        contactPoints,
        roles,
        upn,
        department,
        source: source as ContactEntity['source'], // Added type assertion
      };

      ContactEntitySchema.parse(finalEntity);
      entities.push(finalEntity);
    } catch (error: any) {
      log.error(`Skipping row due to conversion error: ${error.message}`, JSON.stringify(row));
    }
  }
  return entities;
}

// Note: This function might be legacy or used elsewhere. 
// It currently calls rowsToCanonical internally.
export function toCanonical(rawRows: RawOfficeCsvRow[], inputPath: string, verbose: boolean = false): CanonicalExport {
  const contactEntitiesMap = new Map<string, ContactEntity>();
  const potentialSlugs: { [key: string]: number } = {};
  const objectIdSet = new Set<string>();

  // Generate entities using the primary function
  const partialEntities: ContactEntity[] = rowsToCanonical(rawRows, "Office365");

  // Process generated entities for ID collision handling and sorting (specific to this function's purpose)
  partialEntities.forEach((entity) => {
    // Re-check for duplicate ObjectIDs (might occur if rowsToCanonical skips errors silently but still includes some)
    if (objectIdSet.has(entity.objectId)) {
      log.warn(`[toCanonical] Duplicate objectId '${entity.objectId}' detected post-processing for displayName '${entity.displayName}'. Skipping.`);
      return;
    }
    objectIdSet.add(entity.objectId);

    // Count slug collisions based on generated 'id' (which might already be a hash)
    const slug = entity.id; // Use the ID generated by rowsToCanonical
    potentialSlugs[slug] = (potentialSlugs[slug] || 0) + 1;
  });

  partialEntities.forEach((entity) => {
    const slug = entity.id; // Use the already generated ID
    let finalId: string = slug;
    const collisionCount = potentialSlugs[slug] ?? 0;

    // This collision logic might be redundant if rowsToCanonical handles it robustly,
    // but keeping for now if this function has a different use case.
    // If the ID generated by rowsToCanonical (which could be a hash) still collides...
    let uniqueId = finalId;
    let counter = 1;
    while (contactEntitiesMap.has(uniqueId)) {
      uniqueId = `${finalId}-${++counter}`; // Append counter
      log.warn(`[toCanonical] Internal ID collision detected even after initial generation: '${finalId}', appending counter: '${uniqueId}'`);
    }

    const finalEntity: ContactEntity = {
      ...entity,
      id: uniqueId, // Assign the potentially de-collided ID
    };

    // Re-validate just in case
    const validation = ContactEntitySchema.safeParse(finalEntity);
    if (!validation.success) {
      log.warn(`[toCanonical] Skipping entity due to validation error after ID de-collision:`, validation.error.errors);
      return;
    }

    contactEntitiesMap.set(uniqueId, validation.data);
  });

  const contactEntities = Array.from(contactEntitiesMap.values());
  contactEntities.sort((a, b) => (a.displayName ?? '').localeCompare(b.displayName ?? ''));

  log.verbose(`DEBUG [toCanonical]: Assembled ${contactEntities.length} final entities.`);

  return {
    ContactEntities: contactEntities,
    Locations: [], // Keep Locations handling separate
    _meta: {
      generatedFrom: [inputPath],
      generatedAt: new Date().toISOString(),
      version: 1,
      hash: "", // Hash to be computed later
    },
  };
}